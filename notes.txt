Hierarchy of draw cycle
ABlockout
	ALogic
	ACrafter
	
AFormationFactory

ARenderView has timer which launches the renderGame method
На каждый кубик с текстурой или залитый цветом создается отдельно свой буфер и в него
хуячаться координаты, потом буфер вливается в видео память и потом этот буфер отрисовывается

В оперативе создается массив с координатами который скармливается функции OpenGL для
отрисовки

Создать в будущем оптимизацию чтобы конкатенировать все кубики для отрисокви в один видео
буфер - толкать его в видеопамять и рисовать все скопом

//========================================================================================
//
//	All resources must be created and loaded through managers!!!
//	You can find resources only using managers
//
//========================================================================================

AImage - stores RGBA/RGB image in 32-bit/24-bit format in usual RAM. Width, height,
format, and data pointer. It is stand alone class you should manually control it's
creation and deletion

ATGA - only reads TGA format and stores AImage class object pointer.

ATexture - using ATGA and AImage creates OpenGL texture. Stores height, width, format and
texture id - NO IMAGE DATA stores!!!

//========================================================================================
//
//	Все что кассается объектов которые мы собираемся рисовать в сцене должно быть
//	создано из кучи с помощью new и рулиться ACrafter'ом. Ибо если кругом будет юзаться
//	ссылка то придется все время дергать конструктор копирования!!! А так мы кругом
//	перебрасываем несчастные 4 байта указателя.
//
//	Второе вытекающее последствие этот тот факт что дабы хранить и контролировать указатель
//	на свежесозданный блок придется сразу же его заносить в соотв. очередь отрисовки
//
//========================================================================================

Подумать про повторное использование объетов уже созданных.
